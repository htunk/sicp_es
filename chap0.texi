\input texinfo
@comment             **********************************************************
@setfilename         sicp
@settitle            Estructura e Interpretacion de programas computacionales, 2 Ed.
@comment             Formato Texinfo extraoficial
@comment
@set utfversion      2.neilvandyke4
@set utfversiondate  Junio 30,2009
@comment
@comment             Este es un fichero Texinfo. Para convertirlo a formato Info hypertext, 
@comment             necesitas el programa `makeinfo' del packete GNU Texinfo.
@comment             
@comment             Puedes encontrar varias veriones del fichero  sicp.texi y sicp.info
@comment             en las páginas:
@comment             
@comment                 http://www.neilvandyke.org/sicp-texi/
@comment                 [agrega la tuya aquí]
@comment             
@comment             **********************************************************

@comment HISTORY:
@comment
@comment * Version 1 (unknown date) by Lytha Ayth.
@comment
@comment * Version 2 (April 20, 2001) by Lytha Ayth.
@comment
@comment * Version 2.nwv1 (March 11, 2002) by Neil W. Van Dyke.
@comment   Cosmetic change to heading in Info format, and comment changes.
@comment 
@comment * Version 2.neilvandyke1 (February 10, 2003) by Neil W. Van Dyke
@comment   Correction to Exercise 1.39 formula, spotted by Steve VanDevender.
@comment   Added URL of Abelson and Sussman video lectures.
@comment
@comment * Version 2.neilvandyke2 (unreleased)
@comment
@comment * Version 2.neilvandyke3 (April 20, 2006) by Neil W. Van Dyke
@comment   Pedro Kr@"oger patch to add missing Lisp example.
@comment
@comment * Version 2.neilvandyke4 (January 10, 2007) by Neil W. Van Dyke
@comment   Brad Walker patch to add @code{@@dircategory} and @code{@@direntry}.
@comment * Version 2.jorgegarcia1 (Jun 28, 2009) by Jorge A. Garcia Gonzalez

@dircategory El lenguaje algoritmico Scheme
@direntry
h* SICP: (sicp). Estructura e Interpretacion de programas de ordenador
@end direntry


@macro newterm{term}
@cindex \term\
@dfn{\term\}
@end macro

@setchapternewpage odd
@setshortcontentsaftertitlepage

@titlepage
@titlefont{Estructura e Interpretacin}
@sp 0.5
@title  de programas computaciones
@sp 0.2
@subtitle Segunda Edicion
@subtitle  Formato Texinfo extraoficial  @value{utfversion}
@author Harold Abelson y Gerald Jay Sussman
@sp 0.2
@author con colaboracion de  Julie Sussman
@sp 0.4
@author prefacio por  Alan J. Perlis
@sp 0.4

@page
@vskip 0pt plus 1filll
@noindent
Copyright @copyright{} 1996 by The Massachusetts Institute of Technology

@sp 1
@noindent
Estructura e Interpretacion de programas computaciones@*
segunda edicion

@sp 1
@noindent
Harold Abelson y Gerald Jay Sussman@*
con colaboracion de  Julie Sussman

@noindent
prefacio por Alan J. Perlis

@sp 1
@noindent
The @acronym{MIT} Press@*
Cambridge, Massachusetts@*
Londres, Inglaterra

@noindent
McGraw-Hill Book Company@*
New York, St. Louis, San Francisco@*
Montreal, Toronto

@sp 1
@noindent
Este libro es parte de una serie escrita por la facultad de Ingenieria Electrica
y el Departamento de Ciencias de la Computacion del Massachusetts 
Institute of Tecnology ( Instituto Tecnologico de Massachusetts). Editado y producido 
por la editorial @acronym{MIT} bajo contrato de produccion-distribucion junton con McGraw-Hill Company.

@sp 1
@noindent
Formato Texinfo no oficial @value{utfversion} (@value{utfversiondate})

@end titlepage

@node Top, UTF, (dir), (dir)

@ifinfo

@heading Structure and Interpretation of Computer Programs

@noindent
Segunda Edicion@*
Por Harold Abelson y Gerald Jay Sussman, colaboracion de Julie Sussman@*
prefacio por Alan J. Perles@*
@copyrght{} 1996 Massachusetts Institute of Technology

@noindent
Version no oficial en formato Texinfo  @value{utfversion} (@value{utfversiondate})

@end ifinfo

@menu
* UTF::              Formato Texinfo extraoficial
* Dedication::       Dedicatoria
* Foreword::         Prefacio
* Preface::          Prefacio a la segunda edicionn
* Preface 1e::       Prefacio a la primera edicion
* Acknowledgements:: Reconocimientos
* Chapter 1::        Creando Abstracciones con procedimientos
* Chapter 2::        Creando Abstracciones con datos
* Chapter 3::        Modularidad, objetos, y estado
* Chapter 4::        Abstracciones metalinguisticas
* Chapter 5::        Computando con maquinas de registros
* References::       Referencias
* Index::            Indice

@detailmenu
 --- The Detailed Node Listing ---

Programando en Lisp

* 1-1::              Los elementos de la programacion
* 1-2::              Procedimientos y los procesos que generan
* 1-3::              Formulando abstracciones con procedimientos de alto-orden

Los elementos de la programacion

* 1-1-1::            Expresiones
* 1-1-2::            Nombrado y el entorno
* 1-1-3::            Evaluando conbinaciones
* 1-1-4::            Procedimientos compuestos
* 1-1-5::            El modelo de substitucion para aplicacion de procedimientos
* 1-1-6::            Expresiones condicionales y predicados
* 1-1-7::            Ejemplo: Raiz cuadrada por el método de Newton
* 1-1-8::            Procedimientos como abstracciones de caja negra

Procedimientos y los procesos que generan

* 1-2-1::            Recursion lineal e iteracion
* 1-2-2::            Recursion de Tree Recursion
* 1-2-3::            Orden de crecimiento
* 1-2-4::            Exponenciacion
* 1-2-5::            Maximo común divisor
* 1-2-6::            Ejemplo: Prueba de primalidad.

Formulando abstracciones como procedimientos de alto-orden

* 1-3-1::            Procedimientos como argumentos
* 1-3-2::            Construccion de procedimientos usando  @code{Lambda}
* 1-3-3::            Procedimientos como métodos generales
* 1-3-4::            Procedimientos como valores de retorno

Creando abstracciones como datos

* 2-1::              Introduction to Data Abstraction
* 2-2::              Datos jerarquicoso y propiedad closure
* 2-3::              Datos simbolicos
* 2-4::              Multiples representaciones para datos abstractos
* 2-5::              Sistemas con operaciones genericas

Introduccion a los datos abstractos

* 2-1-1::            Ejemplo: Operaciones aritmeticas para números racionales
* 2-1-2::            Barreras abstractas
* 2-1-3::            Que se entiende por datos?
* 2-1-4::            Ejercicio: Aritmética de intervalos.

Datos jerarquicos y propiedad de clausula

* 2-2-1::            Representando secuencias
* 2-2-2::            Estructuras jerarquicas
* 2-2-3::            Secuencias como interfaces convencionales
* 2-2-4::            Ejemplo: Un lenguage para imágenes

Datos simbolicos

* 2-3-1::            Quotation
* 2-3-2::            Ejemplo: Diferenciales simbolicas
* 2-3-3::            Ejemplo: Representando conjuntos
* 2-3-4::            Example: Arboles de Huffman 

Multiples representaciones para datos abstractos

* 2-4-1::            Representaciones para números complejos
* 2-4-2::            Tagged data
* 2-4-3::            Programacion guiada por el dato y aditividad.

Sistemas con operaciones genéricas

* 2-5-1::            Operaciones aritméticas genéricas
* 2-5-2::            Combinando datos de diferentes tipos
* 2-5-3::            Ejemplo: Algebra simbolica

Modularidad, objetos, y estado

* 3-1::              Asignacion y estado local
* 3-2::              El entorno del modelo de evaluacion
* 3-3::              Modelado con datos mutables
* 3-4::              Concurrencia: El tiempo es escencial
* 3-5::              Streams

Asignacion y estado local

* 3-1-1::            Variables con estado local
* 3-1-2::            Los beneficios de introducir asignacion
* 3-1-3::            Los costos de introducir asignacion

El entorno del modelo de evaluacion

* 3-2-1::            Las reglas de evaluacion
* 3-2-2::            Aplicando procedimientos simples
* 3-2-3::            Frames como repositorio de estado local
* 3-2-4::            Definiciones internas

Modelado con datos mutables

* 3-3-1::            Mutable List Structure
* 3-3-2::            Representando colas
* 3-3-3::            Representando tablas
* 3-3-4::            Un simulador de circuitos digitales
* 3-3-5::            Propagacion de limitaciones

Concurrencia: El tiempo es escencial

* 3-4-1::            La naturaleza del tiempo en sistemas concurrentes
* 3-4-2::            Mecanismos para el control de la concurrencia

Streams

* 3-5-1::            Streams como listas retardadas
* 3-5-2::            Streams infinitos
* 3-5-3::            Explotando el paradigma de los Streams
* 3-5-4::            Streams y evaluacion retardada
* 3-5-5::            Modularity of Functional Programs and Modularity of
                     Objects

Abstracciones metalinguísticas

* 4-1::              Evaluador metacircular
* 4-2::              Variaciones en Scheme -- Evaluacion peresoza
* 4-3::              Variaciones en Scheme -- Computacion no determinística
* 4-4::              Programacion Logica

Evaluador metacircular

* 4-1-1::            Nucleo del evaluador
* 4-1-2::            Representando expresiones
* 4-1-3::            Estructuras de datos del evaluador
* 4-1-4::            Ejecutando el evaluador como un programa
* 4-1-5::            Datos como programas
* 4-1-6::            Definiciones internas
* 4-1-7::            Separando el análisis sintáctico de la ejecucion

Variaciones en Scheme -- Evaluacion peresoza

* 4-2-1::            Orden normal y orden aplicativo
* 4-2-2::            Un interprete con evaluacion peresoza
* 4-2-3::            Streams como listas peresozas

Variaciones en Scheme -- Computacion no determinística

* 4-3-1::            Amb y búsqueda
* 4-3-2::            Ejemplos de programas no determinísticos
* 4-3-3::            Implementando el evaluador @code{Amb}

Programcion logica

* 4-4-1::            Recabado de informacion deductiva
* 4-4-2::            Como funciona el sistema de Querys
* 4-4-3::            La programacion logica es logica matemática?
* 4-4-4::            Implementando el sistema de Querys

Implementando el sistema de Querys

* 4-4-4-1::          El bucleThe Driver Loop and Instantiation
* 4-4-4-2::          El Evaluador
* 4-4-4-3::          Buscando aseveraciones por concordancia de patrones
* 4-4-4-4::          Reglas y unificacion
* 4-4-4-5::          Mantenimiento de la base de datos
* 4-4-4-6::          Operaciones sobre Streams
* 4-4-4-7::          Query Syntax Procedures
* 4-4-4-8::          Frames and Bindings

Computando con maquinas de registros

* 5-1::              Diseñando maquinas de registros
* 5-2::              Un simulador de maquinas de registros
* 5-3::              Storage Allocation and Garbage Collection
* 5-4::              El evaluador de control explícito
* 5-5::              Compilacionn

Diseñando maquinas de registros

* 5-1-1::            Un lenguajes para descibir maquinas de registros
* 5-1-2::            Abstracciones en el diseño de maquinas
* 5-1-3::            Subrutinas
* 5-1-4::            Usando una pila para implementar recursion
* 5-1-5::            Instruction Summary

Un simulador de máquinas de registro

* 5-2-1::            La máquina modelo
* 5-2-2::            El ensamblador
* 5-2-3::            Generando procedimientos de ejecucion para las instrucciones
* 5-2-4::            Monitoreo de desempeño de la máquina

Asignacion de almacenamiento y recoleccion de basura

* 5-3-1::            Memoria como vectores
* 5-3-2::            Manteniendo la ilucion de memoria infinita

Registros y operaciones

* 5-4-1::            El núcleo del evaluador de control explícito
* 5-4-2::            Evaluacion de secuencias y recursion de cola
* 5-4-3::            Condicionales, asignacion y definiciones
* 5-4-4::            Ejecutando el evaluador

Descripcion general del compilador

* 5-5-1::            Estructura del compilador
* 5-5-2::            Compilando Expresiones
* 5-5-3::            Compilando Combinaciones
* 5-5-4::            Combinado secuencias de instrucciones
* 5-5-5::            Un ejemplo de codigo compilado
* 5-5-6::            Direccionamiento léxico
* 5-5-7::            Conectando el codigo compilado al evaluador

@end detailmenu
@end menu

@node    UTF, Dedicacion, Top, Top
@unnumbered Unofficial Texinfo Format

@i{Esta es la segunda edicion del libro @acronym{SICP}, extraido desde un fichero en formato extraoficial Texinfo.}

@{Probabelmente estas leyendo desde un browser como el modo Info de Emacs. Alternativamente
podrias leerlo en tu pantalla o impreso en papel.}
}


@i{ @acronym{UTF} es más facil de buscar que @acronym{HTML}. Tambien es más
accesible a personas que tengan computadoras de gama baja, como equipos 386 donados. Un 
386 puede, en teoría, correr Linux, Emacs y un interprete de Scheme simultaneamente, aun cuando 
la mayoria de ellas probablemente  no pueda correr al mismo tiempo Netscape y X window
sin introducir a los jovenes hackers en el concepto de @{thrashing}.} En UTF cabe
perfectamente en un floppy  de 1,44@acronym{MB}, el cual viene bien cuando se
tiene un ordenador sin acceso a INTERNET.

@i{Si modificar @file{sicp.texi} para correjir errores o mejorar el 
@acronym{ASCII} art, modifica la version @code{@@set utfversion @value{utfversion}}
para reflejar tu delta. Por ejemplo, si empesaste con la version de Lytha
@code{1}, y tu nombre es Bob, entonces puedes cambiar el nombre de las versiones sucesivas como
@code{1.bob1}, @code{1.bob2}, @dots{} @code{1.bob@i{n}}.  Tambien cambia la version
@code{utfversiondate}.  Si quieres distribuir tu version en la Web entonces agrega el string ``sicp.texi''
para que la gente pueda encontrarlo con los motores de busqueda web.

@i{
Se cree que el libro extraoficial en formato Texinfo es mantenido con el 
espiritu de la version de distribucion libre en  @acronym{HTML}. Aunque nunca se sabe
cuando la armada de abogados necesitará algo que hacer, asi que piensalo dos veces
antes de usar tu nombre completo.
} 

@noindent
@i{Peath,}

@noindent
@i{Lytha Ayth}

Agregado: Vea tambien las clases SICP por Abelson y Sussman:
@url{http://www.swiss.ai.mit.edu/classes/6.001/abelson-sussman-lectures/}

@node    Dedicacion, Foreword, UTF, Top
@unnumbered Dedication

Este libro está dedicado, con respeto y admiracion, al espíritu que vive en la computadora.


@quotation
``Creo que es extraordinariamente importante que nosotros en las Ciencias de la Computacion, sigamos manteniendo
la diversion. Cuando empezo, habia mucha diversion. Claro que, de vez en cuando
los clientes se quejaba y despues de un tiempo los empezamos a tomar en serio.
Comenzamos a sentirnos realmente responsables por el exito y perfeccion en el uso de
esas maquinas. No creo que lo seammos. Creo que somos responsables por extenderlas, llevarlas
por nuevas direcciones, y de mantener la divercion en casa. Espero que el campo de las
Ciencias de la Computacion nunca pierda su sentido del humor. Sobre todo, espero que nunca
nos convertiremos en misionarios. No te sientas como si fueras un vendedor de biblias. El mundo
ya tiene demasiados. Lo que tu conoces sobre computacion otras personas lo sabrán. No sientas como
si la clave para el éxito de la computacion está solo en tu manos. Lo que sí está en tus manos, creo
y espero, es inteligencia: la habilidad de ver que tu fuiste capaz de hacerla más de lo que te llego a las manos.''

@noindent
---Alan J. Perlis (Abril 1, 1922 @- Febrero 7, 1990)
@end quotation

@node    Foreword, Preface, Dedication, Top
@unnumbered Foreword
Educadores, generales, dietistas, psicologos, y padres, programan. Ejércitos,
estudiantes, y angulas sociedades son programadas. Un enfrentamiento con los grandes problemas
requieren una sucesion de programas, muchos de los cuales 
Estos programas aparecen con problemas que parecen ser particulares únicamente
a los problemas que abordan. Para apreciar la programacion como una actividad
intelectual por sí misma uno mismo debe sumergirce en la programacion; tienes que
leer y escribir los programas -- muchos de ellos. No importa mucho de que trata
el programa o que aplicaciones tiene. Lo que realmente importa es que también
lo realiza o cuan bien encaja con otros programas para crear programas incluso
más grandes. El programador debe buscar a la vez perfeccion de las partes y 
de el conjunto. En este libro el uso de ``programa'' está enfocado en la creacion,
ejecucion, y estudio de programas escritos en un dialecto de lisp para su ejecucion
en computadoras digitales. Usando Lisp nos restringimos o limitamos no en que podemos
programar, si no únicamente la notacion para la descripcion de nuestros programas.

Nuestra jornada en los temas que trataremos en este libro nos llevará con
Los temas que trataremos en éste libro nos envolverá principalmente con tres
tipos de fenomenos: la mente humana, conjuntos de programas computacionales,
y la computadora. 

Cada programa computacional es un modelo, trazado en la mente, de un proceso
real o mental. Estos procesos, surgen desde los pensamientos y la experiecia humana,
son numéricamente son inmensos, intrincados en detalle, y al mismo tiempo parcialmente
comprendidos. 

Ellos estan modelados a nuesta permanente satisfaccion la cual es raramente
lograda por nuestros programas.

Así que incluso cuando nuestros programas son colecciones descretos de símbolos
cuidadosamente colocados como mosaicos de funciones interconectadas, continuamente
evolucionan: los cambiamos a la par de nuestra percepcion del modelo se profundiza,
crece y generaliza hasta que al final el modelo alcanza un lugar estable dentro
de otro modelo con el cual tratamos.

El origen del regocijo que encontramos en las programas computacionales es el continuo
crecimiento en la menta y de los mecanismos de la computadora expresados como programas y la explocion
de percepciones que ellos generan. 
Si el arte es un interprete de nuestros sueños, la computadora los ejecuta en la forma
de programas!

Con todo su poder, la computadora no es nada amistosa. Sus programas deben
correctos, y que todo lo que deseamos decir debe ser dicho con todo detalle. 
Como toda otra actividad simbolica, nos convencemos de la correctes
en los programas mediante la argumentacion. 


Lisp itself can be assigned a semantics (another model, by the way),
and if a program's function can be specified, say, in the predicate calculus,
the proof methods of logic can be used to make an acceptable correctness
argument.  

Desafortunadamente, conforme los programas crecen y se complican, como casi siempre
sucede, la adecuacion, consistencia, y correctes de la especificacion misma se vuelve sujeto
de duda, dado que argumentos formales sobre la correctes de los programas rara vez los acompañan.

Dado que los programas grandes crecen apartir de los pequeños, es crucial que desarrollemos un arsenal
estructuras estandar de aquellas programas que sabemos son correctos --nosotros los llamamos lenguajes--
y aprender a combinarlos en estructuras mayores usando tecnicas de organizacion ha probado ser de gran
valor.

Estas técnicas son tratadas a lo largo de éste libro, y entenderlas, es escencial en la prometedora empresa
llamada programacion. Más que otra cosa, el descubrimiento y dominio de poderosas técnicas de organizacion
aceleran nuestra habilidad para crear programas grandes y complejos. Inversamente, ya que escribir grandes
programas es tan agotador, estamos empujados a inventar nuevos metodos para reducir el conjunto de funciones
y pormenores a ser puestos en los programas.

A diferencia de los programas, los computadores deben obedecer las leyes de la física. Si se desea que ellos
actuen más rapidamente -- menos nanosegundos por cambio de estado --- deben transmitir electrones a menores
distancias. Para lograrlo se necesitaría eliminar el  calor generado por el gran número de 
dispositivos juntos en tan pequeño espacio.

Se ha desarrollado un esquisito arte para balancear la multitud de funciones y la densidad de los
dispositivos. En cualquier momento, el hardware siempre opera a un nivel más primitivo que aquel
en que se encuentran los programas. Los procesos que transforman nuestros programas lisp en programas ``maquina''
son por si mismos modelos abstractos en que programamos. Su estudio y creacion dan una gran cantidad
de conocimiento en la organizacion de estos modelos abstractos en los cuales programamos.

Por supuesto que la computadora por si misma puede ser modelada. Pienselo: el comportamiento
de pequeñas piezas electronicas están modeladas por la mecánica cuántica descrita por
ecuaciones diferenciales cuyo comportamiento es capturado detalladamente por 
aproximaciones representados en programas computaciones ejecutados en en computadoras
compuestas de @dots{}!

No se trata simplemente de una cuestion de conveniencia táctica identificar separadamente
cada uno de las tres facetas. Aunque, como algunos dicen, todo está en la cabeza, ésta
separacion logica conlleva una aceleracion del trafico simbolico entre cada, cuya
riqueza, vitalidad, y potencial es superado en experiencia humana únicamente
al transcurrir la vida misma.

En el mejor de los casos, las relaciones entre los 3 panoramas son metaestables. Las computadoras
nunca son lo sufientemente grandes y rapidas. Cada avance en las tecnologías de hardware nos lleva
a empresas mayores en la programcion de software, nuevos principios organizacionales, y a un enriquecimiento
de modelos abstractos. Cada lector deberia preguntarce a sí mismo de vez en vez, ``Con que fin?, hacia que
fin? ``  - aunque no tan seguido como para dejar perder la diversion debido a tales preguntas filosoficas.

Entre los programas que escribimos, algunos ( aunque nunca son suficientes) desempeñan alguna funcion matematica
muy precisa, como buscar el máximo dentro de una secuencia de números, determinar primaridad, o encontrar
la raiz cuadrada. A tales programas los llamamos algoritmos, y con gran detalles son conocidos por su 
comportamiento optimo, particularmente con respecto de dos parámetros: tiempo de ejecucion y requerimientos del
espacio de almacenamiento. Un programador debe adquirir buenos algoritmos e idiomas.

Incluso aunque algunos programas se resistan a una especificacion precisa, es la responsabilidad del 
programador estimar, y siempre tratar de mejorar, su desempeño.

Lisp es un sobreviviente, habiendo estado en uso cerca de un cuarto de siglo. Entre los lenguajes
de programacion en actividad únicamente Fortran tiene una vida mayor. Ambos lenguajes
han cubierto las necesidades de programacion en importantes areas de trabajo, por ejemplo Fortran
para computacion cienctífica y de ingeniería, Lisp para inteligencia artificial. Éstas dos areas continuarán siendo
importantes, y sus programadores son tan devotos a éstos lenguajes que podrian seguir estando en uso por al menos
otro cuarto de siglo.

Lisp cambia. Scheme es un dialecto usado en éste libro el cual  a evolucionado apartir del Lisp original y difiere
de éste último en varias formas importantes, incluye alcance estático para
la asignacion de variables y permite a las funciones producir funciones
como valores de retorno. En su estrctura semántica Scheme se encuentra tan emparentado con  Algol 60
como lo estuvieron las primeras versiones de Lisp. Algo 60, nunca volvio a ser un lenguaje activo, sin embargo
vive en los genes de Scheme y Pascal. Sería dificil encontrar dos lenguajes que sean la moneda de intercambio 
de dos culturas tan diferentes que las reunidas alrededor de éstos lenguajes. Podríamos ver a Pascal como un
lenguaje para crear piramides --imponentes, asombrosas, estructuras estáticas creadas por ejércitos que apilan
pesados bloques en su lugar. Lisp es para crear organismos --majestuosos, impresionantes, estructuas dinámicas creadas
por escuadrones llenando llenando  --- de organismos más simples en su lugar. Los principios organizacionales usados son los mismos en ambos casos, excepto por una importante y extraordinaria diferencia: 
La libertad de exportar funcionalidades confiada al programador en Lisp, es más de un orden de magnitud mayor
que aquel encontrado en los proyectos con pascal. Los programas lisp inflan las librerias con funciones
cuya utilidad traciende a la aplicacion que las origino.. Las listas, estructuras de datos nativas de Lisp, es
mayormente responsable por dicho crecimiento de utilidad. La aplicabilidad natural de las listas se reflejan
en funciones que son  sorprendentemente no idiosincráticas.   En Pascal la gran cantidad de declaraciones
de estructuras de datos  inducen a una especializacion por parte de las funciones que las procesan, implicando
una inhibicione e incluso penalizacion a la coperacion casual. Es mucho mejor tener 100 funciones que operen
sobre una estructura de datos, que tener 10 funciones que operen sobre 10 estructuras de datos. Como resultado tenemos que las pirámides deben permanecer por milenios; los organismos deben evolucionar o morir.

Para ilustrar la diferencia, compara el tratamiento de materiales y
ejercicios dentro de este libro con cualquiera de mis primeros cursos
usando Pascal. No te dejes llevar por la ilucion de que éste libro es
digerible únicamente en el @acronym{MIT}, Éste es precisamente lo que
un libro serio en programacion en Lisp debe ser, sin importar de donde
o quien sea el estudiante.

Nota que este es un libro sobre programcion en general, a diferencia
de la mayoría de los libros sobre Lisp, las cuales son usados como
preparacion para trabajar en inteligencia artificial. Despues de todo,
las preocupaciones críticas sobre ingeniería de software e
inteligencia artificial tienden a solaparce a medida que el sistema
bajo investigacion se vuelve más grande.

Ésto explica por que existe un crecimiento del interes en Lisp fuera
del campo de inteligencia artificial.

Por sus objetivos, uno podría esperar, que la investigacion en inteligencia artifial 
genere problemas relevantes en programacion. En otras culturas de programacion
ésta avalancha de problemas se refleja en la generacion de nuevos lenguajes. De hecho, en 
cualquier gran proyecto de programacion,  principio util de organizacion es controlar e isolar
el tráfico dentro de las modulos de las tareas con la invencion de nuevos lenguajes. Éstos lenguajes tienden
a ser menos primitivos a medida que uno se aproxima a los limites del sistema en que nosotros, los humanos,
interactuamos más seguido. Como resultado, tales sistemas contienen replicadas muchas veces,funciones complejas 
para el tratamiento del lenguaje. Debido a la sintaxis y semántica tan simple de Lisp la tarea de analizarlo resulta
una tarea elemental. Debido a lo anterior la tarea del analisis sintáctico (parsing)  casi no juega ningun
rol en la programacion en Lisp, y la construccion de procesadores de lenguaje raramente  es un impedimento
para mantener el ritmo de crecimiento y cambios de los grandes sistemas Lisp. Finalmente, ésta simplicidad
de la sintaxis y semantica es la responsable de las preocupaciones y libertades para todos
los programadores en Lisp. Ningun programa en Lisp mayor a unas cuantas lineas puede  ser escrito sin ser saturado
con funciones descrecionales. Inventa y adapta; ten adaptaciones y reinventa! Brindamos por los programadores
que escriben sus pensamientos dentro de parentesis anidados!


@noindent
Alan J. Perlis@*
New Haven, Connecticut

@node    Preface, Preface 1e, Foreword, Top
@unnumbered Preface to the Second Edition

@quotation
Será  posible que no haya nada parecido al software, que esté destinado a ser descartado: 
que siempre tendremos que verlo como una burbuja de jabon?
---Alan J. Perlis
@end quotation

El material en presente en éste libro han sido los fundamentos los temas
de introduccion en el @acronym{MIT} desde 1980. Hemos estado enseñando éste material
por cuadro años cuando la primera edicion fue publicada, y doce años más han
transcurrido desde la aparicion de ésta segunda edicion. Éstamos contentos de que 
nuestro trabajo haya sido adoptado e incorporado en otros textos. Hemos visto a nuestros
estudiantes tomar las ideas y programas en este libro y crearlos en el núcleo de 
nuevos sistemas y lenguajes de computo.  En la realizacion de un antiguo juego de palabras, 
nuestros estudiantes se han convertido en nuestros constructores. Somos afortunados
de tener tan capacez estudiantes y tan consumados constructores.

En la preparacion de ésta edicion, hemos incorporado cientos de aclaraciones
sugeridas por nuestra propia experiencia en la enseñanza y los comentos de colegas
en el @acrnym{MIT} y en otros lados. Hemos redisñado la mayoria de los sistemas de programacion
principales en éste libro, incluyendo los sistemas de aritmética genérica; y hemos reescrito todos los
programas de  ejemplo para asegurar que cualquier implementacion que cumpla @acronym{IEE} Scheme estándar 
(@!acronym{IEEE} 1990) podrá ejecutar el codigo.


Ésta edicion pone énfasis en varios nuevos temas. El más importante es el rol central que jugado por 
las diferentes formas de lidias con tiempo y modelos computacionales:l objetos con estado, programacion concurrente,
programacion funcional, evaluacion perezosa, y programacion no determinística. Incluimos varias secciones nuevas
sobre concurencia y no determinismo, tratando de integrar éstos temas por todo el libro.


La primera edicion de éste libro siguio cuidadosamente el temario de un semestre en el @acronym{MIT}. Con todo 
el  material nuevo en ésta segunda edicion, no será posible curbir todo en únicamente un semestre, por tanto 
el maestro tendrá que escoger que tomar y que no. En nuestra propia experiencia de enseñansa, a veces nos saltamos la seccion sobre programacion logica  (section @ref{4.4}), tenemos estudiantes usando el simulador de la maquina de registros pero no cubrimos su implementacion (section @ref{5-2}), únicamente damos una rápida vista al tema sobre la construccion del compiladores (@ref{5-5}). Incluso con ésto, todavia es un curso intensivo. Algunos instructores tal vez quisieran únicamente cubrir los primeros tres o cuatro capítulos, dejando el resto del material para cursos posteriores.

El sitio Web  @url{http://www-mitpress.mit.edu/sicp/} provee soporte para usuarios de éste libro. Éste incluye
programas del libro, materiales suplementarios e implementaciones ejecutables del dialecto de Lisp, Scheme.

@node    Prefacio 1ra Edicion, Agradecimientos, PrefacioPreface, Arriba
@unnumbered Preface to the First Edition

@quotation
Una computadora es como un violin. Puedes imaginar a un novato tratando primero uno fonografo y despues 
un violin.El último, dice, suena terrible. Éste es el argumento que escuchamos de nuestros humanistas, y 
la mayoría de nuestros científicos computacionales. Los programas computacionales son buenos, dicen, para 
propositos particulares, sin embargo no son flexibles. Tampoco el violin, o una máquina de escribir, hasta
que se aprenda a usarlo.

---Marvin Minsky, ``Por que la programacion es un buen medio para expresar ideas pobremente comprendidas o no muy bien formuladass''
@end quotation
``La estructura e interpretacion de programas computacionales'' es el material 
de iniciacion en ciencias de la computacion en el Instituto Tecnologico de Massachusetts. Es requerido que
todos los estudiantes de ingeniría electrica o ciencias de la computacion tomen éste curso,  se concidera
como un cuarto del ``núcleo curricular común', el cual tambien incluye temas 
sobre circuitos y sistemas lineales, además otro sobre diseño de sistemas digitales. Hemos estado
involucrados en el desarrollo de éste asunto desde 1978, y hemos estado enseñando
éste material tal como se encuenta ahora desde el otoño del 1980 con entre 600 y 700 estudiantes
por año.
La mayoria de estos estudiantes han tenido poco o ninguna enseñanza formal a priori en computacion., aunque
muchos de ellos haya jugado con computadoras un poco y menos han tenido mucha experiencia programando 
o diseñando hardware.

El diseño de este tema de introduccion a las ciencias de la computacion reflaja dos grandes preocupaciones. Primero,
que los lenguajes de programacion no son solo una forma de lograr que una computadora realice una tarea, si no que 
es en realidad una novedosa forma de expresar ideas sobre metodología. Por tanto, programas deben ser escritos
para ser leidos por personas, e incidentalmente para ser ejecutadas por máquinas. Segundo, creemos que el material
expuesto por éste tema en éste nivel, no es la sintaxis de las contrucciones sintacticas de un lenguaje de 
programacion en particular, ni ingeniosos algoritmos para calcular alguna funcion en particular eficientemente, más bien las técnicas usadas para controlar la complejidad intelectual de los grandes sistemas de software.

Nuestro objetivo es que los estudiantes que completen éste tema deban tener un buen
sentido del gusto del estilo y estética de la programacion. Ellos deben tener
dominio sobre las técnicas de control de complejidad mayores. Ellos deben ser capaces de leer
un programa de 50 hojas de longitud, if está escrito en un estilo ejemplar. Ellos deben saber 
que no necesitan leer, y que no necesitan entender en cualquier momento. Deben sentirce seguros
al modificar un programa, reteniendo el espíritu y estilo del autor original.

Éstas habilidades no son únicas de la programacion de computadoras. Las técnicas que enseñamos
son comunes a todo el diseño de ingeniería. Contralamos la complejidad, creando abstracciones que
oculten detalles cuando sea apropiado. Controlamos complejidad, estableciendo interfaces que
nos permiten construir sistemas, combinando piezas estandar, bien documentadas en una forma
``mescla y encaja''. Controlamos complejidad al establecer nuevos lenguajes para describir
un diseño, cada uno de los cuales enfatiza un particular aspecto del diseño y desenfatiza otros.


Lo que hay por debajo de nuestra aproximacion a éste tema es nuestra conviccion de 
que ``las ciencias de la computacion'' no es una ciencia y que su signifado
tiene poco que ver con las computadoras. La revolucion informática, es una revolucion en
la manera en que pensamos y en la forma que expresamos lo que pensamos. La escencia de éste
cambio es lo que podría ser llamado @newterm{epistemología procedural}---el estudio de
la estructura del conociemiento desde un punto de vista imperativo, en oposicion al punto
de vista declarativo tomado por las ramas clasicas de las matemáticas.
Las matemáticas proveen un entorno para tratar precisamente con la nocion de ``que es'' , 
la computacion provee un entorno para tratar precisamente con la nocion de ``como hacerlo.''

Enseñando nuestro material usamos un dialecto del leguaje de programacion Lisp. Formalmente
nunca enseñamos el lenguaje, debido a que no necesitamos hacerlo. Solo lo usamos, y los 
estudiantes lo aprenden luego de unos pocos dias. Ésta es una de las grandes ventajas
de los lenguajes parecidos a Lisp: Tienen muy pocas formas de componer expresiones, y casi 
ninguna estructura sintáctica. Todas las propiedades formales pueden ser cubiertas en una hora, al
igual que las reglas de ajedrez. Despues de un corto tiempo nos olvidamos de los detalles
de la sintaxis del lenguaje ( por que no tiene) y nos topamos con lo que 
realmente importa ---idear que queremos computar, como dividiremos el problema en partes 
manejables, y como trabajaremos sobre esas partes. Otra ventaja de Lisp es que soporta
(aunque no fuerza) más de una estrategia para descomponer programas de gran escala
estrategias para la  descomposicion modular de sistemas que cualquier otro lenguaje 
de programacion que conoscamos soporta. Podemos crear abstraciones de datos y procedurales, 
podemos usar funciones de orden alto para capturar patrones de uso comun, podemos modelar
estado local usando asignacion y mutacion de datos, podemos enlazar partes de un programa con 
streams y evaluacion retrasada, y podemos implementar facilmente lenguajes empotrados.
Todo ésto está embebido en un entorno interactivo con excelente soporte para el diseño incremental de
programas, su contruccion, prueba y revision. Agradecemos a todas las generaciones de magos de Lisp, empezando
con John McCarthy, quien puso de moda una estupenda herramienta  con poder y elegancia sin precedentes.

El dialecto de Lisp que usamos es Scheme, en un intento de lograr juntar el poder y elegancia de Lisp y Algol. De
Lisp tomamos el poder metalinguístico que deriva de su sintaxis tan simple, la representacion uniforme de programas
como objetos de datos, y el colector de basura y colector de datos alojados. De Algol tomamos el alcance
léxico y la estructura de bloques, los cuales son legados de los pioneros el diseño de los lenguajes de programacion
quienes estuvieron en el comité de Algol. 
Scheme, the dialect of Lisp that we use, is an attempt to bring together the
power and elegance of Lisp and Algol.  From Lisp we take the metalinguistic
power that derives from the simple syntax, the uniform representation of
programs as data objects, and the garbage-collected heap-allocated data.  From
Algol we take lexical scoping and block structure, which are gifts from the
pioneers of programming-language design who were on the Algol committee.  We
wish to cite John Reynolds and Peter Landin for their insights into the
relationship of Church's @i{[lambda]} calculus to the structure of programming
languages.  We also recognize our debt to the mathematicians who scouted out
this territory decades before computers appeared on the scene.  These pioneers
include Alonzo Church, Barkley Rosser, Stephen Kleene, and Haskell Curry.

@node       Reconocimientos, Capítulo 1, Prefacio 1ra ed, Arriba
@unnumbered Acknowledgements

Nos gustaría agradecer a todas las personas que nos apoyaron a desarrollar éste libro y su curricula.

Nuestra materia es un claro descendiente de ``6.231,'' un materia sobre liguística de programacion y el cálculo @i{lambda}
enseñado en el @acronym{MIT} a finales de 1960 por Jack Wozencraft y Arthur Evans, Jr.

Tenemos una gran deuda con Robert Fano, quien reorganizo la curricula introductoria en Ingeniería Electrica y Ciencias 
de la Computacion del @acronym{MIT} para enfatizar los principios de la ingeniria de diseño. El nos guio para que empezaramos
ésta empresa y escribio el primer conjunto de notas de los temas de los cuales se desarrollo éste libro.

Mucho del estilo y estética de la programacion que tratamos de enseñar fue desarrollada en conjunto con Guy Lewis Steele Jr. , 
quien colaboro con Gerald Jay Sussman en el desarrollo inicial del lenguaje de programacion Scheme. Adicionalmente, David Turner, 
Peter Henderson, Dan Friedman, David Wise, y Will Clinger nos han enseñado muchas de las técnicas de la programacion funcional de la comunidad que aparece en éste libro.

Joel Moses nos enseño como estructurar grandes sistemas. Sus experiencia con el sistema Macsyma para computacion simbolica
nos enseño que uno debe evitar la complejidad en el control y concentrarse en organizar los datos para que reflejen la verdadera
estructura del mundo que está siendo modelado.

Marvin Minsky y Seymour Papert formaron muchas de las actitudes sobre la programacion y su lugar en nuestras vidas intelectuales.  A ellos les debemos el saber que la computacion provee medios de expresion para explorar ideas de otro modo sería muy complejo
de abordar prescisamente.  Ellos enfantizan que la habilidad de un estudiante para escribir y modificar programas provee un 
poderoso medio en el cual explorar se combierte en una actividad natural.

Estamos fuertemente de acuerdo con Alan Perlies que la programacion es muy divertida y que mejor hemos de tener cuidado de
apoyar la diversion de la programacion. Parte de que sea divertido se deriva de observar a los grandes maestros trabajando. Somos
afortunados de haber sido aprendices de programaciono a los pies de Bill Gosper y Richard Greenblat.

Es dificil identificar todas las peronas quienes han contribuido al desarrollo de nuestro curriculum. Agradecemos a los
profesores, instructores, y tutores quienes han trabajado con nosotros los pasados quince años y puesto tantas horas
extra en nuestra materia, especialmente Bill Siebert, Albert Meyer, Joe Stoy, Randy Davis, Louis Braida, Eric Grimson, Rod Brooks, Lynn Stein, y Peter Szolovits. Nos gustaría agradecer especialmente la  sobresaliente contribucion a la enseñansa de Franklyn Turbak, ahora en Wellesley; su trabajo en la instruccion de pregrado ha puesto un estandar al cual todos podemos aspirar. Estamos 
agradecidos a Jerry Saltzer y Jimm Miller por ayudarnos a lidiar con los misterios de la concurrencia, y a Peter Szolovits y David McAllester por sus contribuciones en la exposicion de la evaluacion no determinística en @ref{Chapter 4}.

Muchas personas han puesto un esfuerzo significativo para presentar éste material en otras universidades. Alguanas de las 
personas con que hemos trabajado muy cercanamente son Jacob Katzenelson en el Tecnion, Hardy Mayers en la Universidad de 
California en Irvine, Joe Stoy en Oxford, Elisha Sacks en Purdue, y Jan Komorowski en la Universidad Norwegian de Ciencia y 
Tecnología. Estamos excepcionalmente orgullosos de éste tema en otras universidades, incluyhendo Kenneth Yip en Yale, Brian Harvey
en la Universidad de California en Berkeley, y Dan Huttenlocher en Cornell.

Al Moy@'e organizo para nosotros la enseñanza de éste material a los ingenieros de Hellet-Packard, así como la produccion de
cintas de video de esas clases. Nos gustaría agradecer a los talentosos instructores, en particular a Jim Miller, Bill Siebert, y Mike Eisenberg, quien han diseñado los cursos de educacion continua incorporando éstas cintas y enseñandolas en universidades
e industrias alrededor de todo el mundo.

Muchos educadores en otros paises han puesto un significativo esfuerzo traduciendo la primera edicion. Michel Briand, Perre Chamard, y André Pic produjeron una edicion en frances; Sussane Daniels-Herold produjeron una edicion en Aleman; y Fumio Motoyoshi produjeron una edicion en japones. No sabemos quien produjo la edicion en chino, pero consideramos un honor, haber sido seleccionados 
como el tema una traduccion ``no autorizada''.

Es dificil enumerar todas las personas quen han hecho contribuciones técnicas al desarrollo de los sistemas Scheme que usamos
para propositos de enseñaza. Además de Guy Steele, entre los principales magos se han incluido Cris Hanson, Joe Bowbeer, Jim Miller, Guillermo Rozas y Stephen Adams. Otros quienes han puesto un tiempo significativo son Richard Stallman, Alan Bawden, Kent Pitman
, Jon Taft, Neil  Mayle, John Lamping, Gwyn Osnos, Tracy Larrabee, George Carrette, Soma
Chaudhuri, Bill Chiarchiaro, Steven Kirsch, Leigh Klotz, Wayne Noss, Todd Cass,
Patrick O'Donnell, Kevin Theobald, Daniel Weise, Kenneth Sinclair, Anthony
Courtemanche, Henry M. Wu, Andrew Berlin, and Ruth Shyu.

Nos gustaría agradecer, no solo por la implementacion del @acronym{MIT}, a todas las personas quienes trabajaron en 
el estandard @acronym{IEEE} de Scheme, incluyendo a William Clinger y a Jonathan Rees, quien edito el @acrnym{R^4RS}, y a Chris Haynes, David Bartley, Chris Hanson, y Jim Miller, quienes prepararon el estandar @acronym{IEEE}. 

Dan Friedman ha sido un viejo lider de la comunidad de Scheme. La mayoría del trabajo de la comunidad va desde
los problemas en el diseño del lenguaje hasta abarcar incluso inovaciones significativas en el ambito educacional, 
tal como las las curriculas de bachillerato basadas en el EdScheme de Schemer's Inc., y los maravillosos libros de Mike Eisenberg
,Brian Harve y Matthew Wright.

Apreciamos el trabajo de aquellos quienes contribuyeron a que este libro se hiciera realidad, especialmente a Terry Ehling, 
Larry Cohen, y Paul Bethge en @acronym{MIT} Press. Ella Mazel encontro la maravillosa imagen de la portada. Estamos particularmente agradecidos a Bernard y Ella Mazel por su ayuda con el diseño del libro en su segunda edicion, tambien al extraordinario mago del @TeX{} David Jones. Tambien estamos en deuda a todos aquellos lectores quienes hicieron perspicaces comentarios en el nuevo borrados: Jacob Katzenelson, Hardy Mayer, Jim Miller, y especialmente Brian Harvey, quien hizo en éste libro lo que Jolie sobre su libro @cite{Simply Scheme}.

Finalmente, nos gustariía reconocer la ayuda de las organizaciones que han apoyado éste trabajo al pasar de los años, por parte de  Hewlett-Packard: Ira Goldstein y Joel Birnbaum, por parte de @acronym{DARPA}: Bob Kahn.

@node    Capitulo 1, Capitulo 2, Agradecimientos, Arriba

@chapter Creando abstracciones mediante procedimientos
